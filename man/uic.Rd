% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uic.R
\name{uic}
\alias{uic}
\title{Batch processing to compute UIC}
\usage{
uic(
  block,
  lib = c(1, NROW(block)),
  pred = lib,
  x_column = 1,
  y_column = 2,
  z_column = NULL,
  norm = 2,
  E = 1,
  tau = 1,
  tp = 0,
  nn = "e+1",
  n_boot = 2000,
  scaling = c("neighbor", "velocity", "no_scale"),
  exclusion_radius = NULL,
  epsilon = NULL,
  is_naive = FALSE
)
}
\arguments{
\item{block}{a data.frame or matrix where each column is a time series}

\item{lib}{the time range to be used for attractor reconstruction}

\item{pred}{the time range to be used for prediction forecast}

\item{x_column}{the name or column index of library data}

\item{y_column}{the name or column index of target data}

\item{z_column}{the name or column index of condition data}

\item{norm}{the power of Lp norm (if p < 0, max norm is used)}

\item{E}{the embedding dimension}

\item{tau}{the time-lag for delay embedding}

\item{tp}{the time index to predict}

\item{nn}{the number of neighbors}

\item{n_boot}{the number of bootstrap to be used for computing p-value}

\item{scaling}{the local scaling (neighbor, velocity, no_scale)}

\item{exclusion_radius}{the norm filtering (time difference < exclusion_radius)}

\item{epsilon}{the norm filtering (d < epsilon)}

\item{is_naive}{whether rEDM-style estimator is used}
}
\value{
A data.frame with model parameters, root mean squared errors, uic and p-value
}
\description{
Batch processing to compute UIC
}
\examples{
## simulate logistic map
tl <- 400  # time length
x <- y <- rep(NA, tl)
x[1] <- 0.4
y[1] <- 0.2
for (t in 1:(tl - 1)) {  # causality : x -> y
    x[t+1] = x[t] * (3.8 - 3.8 * x[t] - 0.0 * y[t])
    y[t+1] = y[t] * (3.5 - 3.5 * y[t] - 0.1 * x[t])
}
block = data.frame(t = 1:tl, x = x, y = y)

## UIC
op0 = uic(block, x_column = "x", y_column = "y", E = 3, tau = 1, tp = -4:0, n_boot = 2000)
op1 = uic(block, x_column = "y", y_column = "x", E = 3, tau = 1, tp = -4:0, n_boot = 2000)
par(mfrow = c(2, 1))
with(op0, plot(tp, te, type = "l"))
with(op0[op0$pval < 0.05,], points(tp, te, pch = 16, col = "red"))
with(op1, plot(tp, te, type = "l"))
with(op1[op1$pval < 0.05,], points(tp, te, pch = 16, col = "red"))

}
