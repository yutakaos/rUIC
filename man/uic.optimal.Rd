% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uic.optimal.R
\name{uic.optimal}
\alias{uic.optimal}
\title{Wrapper function for computing unified information-theoretic causality
for the optimal embedding dimension.}
\usage{
uic.optimal(
  block,
  lib = c(1, NROW(block)),
  pred = lib,
  group = NULL,
  lib_var = 1,
  tar_var = 2,
  cond_var = NULL,
  norm = 2,
  E = 1,
  tau = 1,
  tp = 0,
  nn = "e+1",
  num_surr = 1000,
  alpha = 0.05,
  sequential_test = FALSE,
  exclusion_radius = NULL,
  epsilon = NULL,
  is_naive = FALSE,
  knn_method = c("KD", "BF")
)
}
\arguments{
\item{block}{a data.frame or matrix where each column is a time series.}

\item{lib}{a two-column matrix (or two-element vector) where each row specifies the
first and last indices of time series to use for attractor reconstruction.}

\item{pred}{a two-column matrix (or two-element vector) where each row specifies the
first and last indices of time series to use for model predictions.}

\item{group}{the name or column index of a group variable, which specifies different
groups of time series data.}

\item{lib_var}{the names or column indices of library variables.}

\item{tar_var}{the names or column indices of target variables.}

\item{cond_var}{the names or column indeices of condition variables, which are used as
library variables without time-delay embedding.}

\item{norm}{the power of Lp distance. Maximum distance is used if \code{norm} == Inf.}

\item{E}{the embedding dimensions used for time-delay embedding.}

\item{tau}{the time-lag used for time-delay embedding. Must be an integer.}

\item{tp}{the time indices to predict.}

\item{nn}{the number of nearest neighbors. Must be an integer or "e+1".
If \code{nn = "e+1"} or \code{nn = -1}, \code{nn} is set to \code{E} + 1.
If \code{nn = 0}, \code{nn} is set to the number of all data.}

\item{num_surr}{the number of surrogate data generated to compute p-value.}

\item{alpha}{the significant level to determine the embedding dimension of reference model
(i.e., E0). If \code{alpha = NULL}, E0 is set to E - 1. If \code{0 < alpha < 1} 
E0 depends on the model results with lower embedding dimensions. Default is
0.05.}

\item{sequential_test}{if \code{sequential_test = TRUE}, the function explores the optimal \code{tp} based
on sequential conditional test.}

\item{exclusion_radius}{the filtering to exclude nearest neighbors if their time index is within
exclusion radius.}

\item{epsilon}{the filtering to exclude nearest neighbors if their distance is farther
away than epsilon.}

\item{is_naive}{specifies whether naive estimator is used or not.}

\item{knn_method}{the method to search nearest neighbors.
The KD-tree ("KD") or brute-force ("BF") search can be used.}
}
\value{
A data.frame where each row represents model statistics computed from a parameter set.
See the details in Value section of \code{uic}.
If \code{sequential_test = TRUE}, the data.frame includes an additional column
\code{seq_test}. The \code{tp} with \code{seq_test} = i > 0 were selected as optimal
by the i-th sequential test. The causal effect of \code{tp} with \code{seq_test} = -i
< 0 is blocked by \code{tp} with \code{seq_test} = i.
}
\description{
\code{uic.optimal} returns model statistics computed from given multiple time
series using simplex projection and cross mapping. This function computes UICs
after exploring the optimal \code{E} based on simplex projection. The users do
not have to determine the optimal \code{E} by themselves.
}
\examples{
# simulate logistic map
tl <- 400  # time length
x <- y <- rep(NA, tl)
x[1] <- 0.4
y[1] <- 0.2
for (t in 1:(tl - 1)) {  # causality : x -> y
    x[t+1] = x[t] * (3.8 - 3.8 * x[t] - 0.0 * y[t])
    y[t+1] = y[t] * (3.5 - 3.5 * y[t] - 0.1 * x[t])
}
block <- data.frame(t=1:tl, x=x, y=y)

out0 <- uic.optimal(block, lib_var="x", tar_var="y", E=0:8, tau=1, tp=-4:4, sequential_test=TRUE)
out1 <- uic.optimal(block, lib_var="y", tar_var="x", E=0:8, tau=1, tp=-4:4, sequential_test=TRUE)
par(mfrow=c(2,2))
with(out0, plot(tp, ete, type="b", pch=c(1,16)[1+(pval<0.05)]))
with(out1, plot(tp, ete, type="b", pch=c(1,16)[1+(pval<0.05)]))
with(out0, plot(tp, ete, type="b", pch=c(1,16)[1+(seq_test>0)]))
with(out1, plot(tp, ete, type="b", pch=c(1,16)[1+(seq_test>0)]))

}
\seealso{
\link{simplex}, \link{uic}
}
